# object detector boot.py
# generated by maixhub.com

import sensor, image, lcd, time, struct
import KPU as kpu
import gc, sys
from fpioa_manager import fm
from machine import UART


# 串口接收控制类
class Receive(object):
    def __init__(self,mode,uart):
        self.uart_buf   = []
        self.state      = 0
        self.uart       = uart
        self.WorkMode   = mode
    #读取串口缓存
    def UartReadBuffer(self):
        i = 0
        Buffer_size = self.uart.any()
        while i<Buffer_size:
            self.ReceivePrepare(self.uart.readchar())
            i = i + 1
    #串口通信协议接收
    def ReceivePrepare(self,data):
        if self.state == 0 :
            if data == 0xAA:#帧头
                self.uart_buf.append(data)
                self.state = 1
            else:
                self.state = 0
        elif self.state == 1 :
            self.uart_buf.append(data)
            self.state = 2
        elif self.state == 2 :
            self.state = 0
            self.uart_buf.append(data)
            self.ReceiveAnl()
            self.uart_buf = []#清空缓冲区，准备下次接收数据
        else:
            self.state = 0
    #串口数据解析
    def ReceiveAnl(self) :
        #校验
        if self.uart_buf[1] == self.uart_buf[2] :
            self.WorkMode = self.uart_buf[1]
# 目标数据类
class goal_data(object):
    """
        flag:是否找到标志位，0x00(未找到) 0x01(已找到)
        goal:找到的目标。0x00(起点) 0x01(A点) 0x02(B点) 0x03(C点)
         x  :目标中心横坐标
         y  :目标中心纵坐标
    """
    def __init__(self,x,y):
        self.goal   = 0
        self.x      = x
        self.y      = y
    def data_pack(self,workflag):
        # 0xAA:帧头; 0x01:功能字; 0x06:有效位数; 0x00:和校验位
        t_data = bytearray([0xAA,0x01,0x06,self.goal,workflag,self.x[-1]>>8,self.x[-1],self.y[-1]>>8,self.y[-1],0x00])
        sum = 0
        for i in range(0,len(t_data)-1):
            sum += t_data[i]
        t_data[-1]=sum
        return t_data

Dot=goal_data([0,0,0,0],[0,0,0,0])

#引脚配置
fm.register( 6, fm.fpioa.UART1_TX, force=True)
fm.register( 7, fm.fpioa.UART1_RX, force=True)
fm.register(10, fm.fpioa.UART2_TX, force=True)
fm.register( 9, fm.fpioa.UART2_RX, force=True)
#初始化串口 波特率 500000
uart_A = UART(UART.UART2, 500000, 8, None, 1, timeout=1000, read_buf_len=4096)
uart_B = UART(UART.UART1, 500000, 8, None, 1, timeout=1000, read_buf_len=4096)
Receive_A = Receive(0,uart_A)     # 串口接收控制类实例化
Receive_B = Receive(0,uart_B)
# 低通滤波
# 输入参数：旧值(4列表)、新值、新值比例（取值（0,1],1:全信新值）
# 作用：数据平滑
def low_pass_filter(o_value,n_value,ratio = 0.5):
    o_value[0] = (1-ratio)*o_value[0] + ratio*n_value
    o_value[1] = (1-ratio)*o_value[1] + ratio*o_value[0]
    o_value[2] = (1-ratio)*o_value[2] + ratio*o_value[1]
    o_value[3] = int(o_value[2])


def data_update(num,x_value,y_value,workflag):
    low_pass_filter(Dot.x,x_value-112)
    low_pass_filter(Dot.y,y_value-112)
    Dot.goal = num
    uart_A.write(Dot.data_pack(workflag))

def lcd_show_except(e):
    import uio
    err_str = uio.StringIO()
    sys.print_exception(e, err_str)
    err_str = err_str.getvalue()
    img = image.Image(size=(224,224))
    img.draw_string(0, 10, err_str, scale=1, color=(0xff,0x00,0x00))
    lcd.display(img)

def main(anchors, labels = None, model_addr="/sd/m.kmodel", sensor_window=(224, 224), lcd_rotation=0, sensor_hmirror=False, sensor_vflip=False):
    sensor.reset()
    sensor.set_pixformat(sensor.RGB565)
    sensor.set_framesize(sensor.QVGA)
    sensor.set_windowing(sensor_window)
    sensor.set_hmirror(sensor_hmirror)
    sensor.set_vflip(sensor_vflip)
    sensor.run(1)
    lcd.init(type=1)
    lcd.rotation(lcd_rotation)
    lcd.clear(lcd.WHITE)
    if not labels:
        with open('label.txt','r') as f:
            exec(f.read())
    if not labels:
        print("no label.txt")
        img = image.Image(size=(320, 240))
        img.draw_string(90, 110, "no label.txt", color=(255, 0, 0), scale=2)
        lcd.display(img)
        return 1
    try:
        img = image.Image("startup.jpg")
        lcd.display(img)
    except Exception:
        img = image.Image(size=(320, 240))
        img.draw_string(90, 110, "loading model...", color=(255, 255, 255), scale=2)
        lcd.display(img)

    try:
        task = None
        task = kpu.load(model_addr)
        kpu.init_yolo2(task, 0.5, 0.3, 5, anchors) # threshold:[0,1], nms_value: [0, 1]
        while(True):
            img = sensor.snapshot()
            t = time.ticks_ms()
            objects = kpu.run_yolo2(task,img)
            t = time.ticks_ms() - t
            Receive_B.UartReadBuffer()
            if objects:
                min_wh=float('inf')
                pos1=0
                for obj in objects:
                    pos = obj.rect()
                    if pos[2]*pos[3]>min_wh:
                        continue
                    else:
                        pos1 = pos
                        min_wh=pos[2]*pos[3]
                    if obj.classid()==0:    #标注1 起点
                        data_update(1,pos[0]+0.5*pos[2],pos[1]+0.5*pos[3],Receive_B.WorkMode)
                    else:
                        data_update(2,pos[0]+0.5*pos[2],pos[1]+0.5*pos[3],Receive_B.WorkMode)
                img.draw_rectangle(pos1)
                img.draw_string(pos1[0], pos1[1], "%s : %.2f" %(labels[obj.classid()], obj.value()), scale=2, color=(255, 0, 0))
            else:
                data_update(0, 0, 0, Receive_B.WorkMode)
            img.draw_string(0, 200, "t:%dms" %(t), scale=2, color=(255, 0, 0))
            lcd.display(img)
    except Exception as e:
        raise e
    finally:
        if not task is None:
            kpu.deinit(task)


if __name__ == "__main__":
    try:
        labels = ["ʮ", "A"]
        with open("anchors.txt", 'r') as f:
            anchors = f.readline()
        anchors = [float(x) for x in anchors.split(',')]
        #anchors = [2.977475881576538, 3.140728712081909, 3.1870858669281006, 3.2334437370300293, 3.360927104949951, 3.349337577819824, 3.663669109344483, 3.7433772087097172, 4.311258316040039, 4.264900207519531]
        # main(anchors = anchors, labels=labels, model_addr=0x300000, lcd_rotation=0)
        main(anchors = anchors, labels=labels, model_addr="/sd/m.kmodel")
    except Exception as e:
        sys.print_exception(e)
        lcd_show_except(e)
    finally:
        gc.collect()
